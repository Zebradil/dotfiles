# vim: set filetype=zsh shiftwidth=2 softtabstop=2 expandtab:

# +=========================+
# | Library                 |
# +-------------------------+

RCol='\e[0m'    # Text Reset

# Regular           Bold                Underline           High Intensity      BoldHigh Intens     Background          High Intensity Backgrounds
Bla='\e[0;30m';     BBla='\e[1;30m';    UBla='\e[4;30m';    IBla='\e[0;90m';    BIBla='\e[1;90m';   On_Bla='\e[40m';    On_IBla='\e[0;100m';
Red='\e[0;31m';     BRed='\e[1;31m';    URed='\e[4;31m';    IRed='\e[0;91m';    BIRed='\e[1;91m';   On_Red='\e[41m';    On_IRed='\e[0;101m';
Gre='\e[0;32m';     BGre='\e[1;32m';    UGre='\e[4;32m';    IGre='\e[0;92m';    BIGre='\e[1;92m';   On_Gre='\e[42m';    On_IGre='\e[0;102m';
Yel='\e[0;33m';     BYel='\e[1;33m';    UYel='\e[4;33m';    IYel='\e[0;93m';    BIYel='\e[1;93m';   On_Yel='\e[43m';    On_IYel='\e[0;103m';
Blu='\e[0;34m';     BBlu='\e[1;34m';    UBlu='\e[4;34m';    IBlu='\e[0;94m';    BIBlu='\e[1;94m';   On_Blu='\e[44m';    On_IBlu='\e[0;104m';
Pur='\e[0;35m';     BPur='\e[1;35m';    UPur='\e[4;35m';    IPur='\e[0;95m';    BIPur='\e[1;95m';   On_Pur='\e[45m';    On_IPur='\e[0;105m';
Cya='\e[0;36m';     BCya='\e[1;36m';    UCya='\e[4;36m';    ICya='\e[0;96m';    BICya='\e[1;96m';   On_Cya='\e[46m';    On_ICya='\e[0;106m';
Whi='\e[0;37m';     BWhi='\e[1;37m';    UWhi='\e[4;37m';    IWhi='\e[0;97m';    BIWhi='\e[1;97m';   On_Whi='\e[47m';    On_IWhi='\e[0;107m';

_zshrc_warn() {
  printf "${IYel}%s${RCol}\n" "$1" >&2
}


# +=========================+
# | Fuzzy finder            |
# +-------------------------+

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

export FZF_DEFAULT_OPTS='--multi --no-height --extended'
export FZF_DEFAULT_COMMAND='fd --no-ignore --hidden --exclude ".git" --exclude "~/go"'
export FZF_CTRL_T_COMMAND="${FZF_DEFAULT_COMMAND}"
# TODO transform these commands to functions
FZF_PREVIEW_MAX_LINES=200
FZF_DIRECTORY_PREVIEW_CMD="exa -l --group-directories-first -T -L5 --color=always --color-scale {} | head -${FZF_PREVIEW_MAX_LINES}"
FZF_TEXT_FILE_PREVIEW_CMD="bat -pp --italic-text=always --color=always -r:${FZF_PREVIEW_MAX_LINES}"
export FZF_ALT_C_OPTS="--preview '${FZF_DIRECTORY_PREVIEW_CMD}'"

# Use fd (https://github.com/sharkdp/fd) instead of the default find
# command for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversal
# - See the source code (completion.{bash,zsh}) for the details.
_fzf_compgen_path() {
  eval ${FZF_DEFAULT_COMMAND} --follow . "$1"
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
  eval ${FZF_DEFAULT_COMMAND} --follow --type d . "$1"
}

# (EXPERIMENTAL) Advanced customization of fzf options via _fzf_comprun function
# - The first argument to the function is the name of the command.
# - You should make sure to pass the rest of the arguments to fzf.
_fzf_comprun() {
  local command=$1
  shift

  case "$command" in
    cd)           fzf "$@" --preview "${FZF_DIRECTORY_PREVIEW_CMD}" ;;
    export|unset) fzf "$@" --preview "eval 'echo \$'{}" ;;
    ssh)          fzf "$@" --preview 'dig {}' ;;
    man)          man -k . | fzf --prompt='Man> ' --preview 'man $(echo {} | awk "{print \$1}") | '"${FZF_TEXT_FILE_PREVIEW_CMD} -lman" | awk '{print $1}' ;;
    vi|vim|nvim)  fzf "$@" --preview "[ -f {} ] && ${FZF_TEXT_FILE_PREVIEW_CMD} {} || ${FZF_DIRECTORY_PREVIEW_CMD}" ;;
    pacman)       pacman -Qq | fzf --preview 'pacman -Qi {}' ;;
    *)            fzf "$@" ;;
  esac
}

fzf-find-command-widget() {
  # TODO Add aliases and maybe builtins and functions
  LBUFFER=$(printf '%s\n' "${commands[@]}" \
    | fzf --preview '
      set -o pipefail
      cmd=$(basename {})
      pacman --color=always -Qo {}
      ( man $cmd | '"${FZF_TEXT_FILE_PREVIEW_CMD} -lman"' ) \
      || (
        set -e
        pkg=$(pacman -Qoq {} 2>/dev/null)
        pacman -Qi ${pkg} | rg "Description\s+:\s*(.*)" --only-matching --replace="\$1"
      )')
  zle redisplay
}

zle     -N    fzf-find-command-widget
bindkey '\ex' fzf-find-command-widget


function frg() (
rg "$@" --files-with-matches \
    | fzf --preview "rg --color always -A5 -B5 \"$@\" {}"
)

function chct() (
  local alclr=alacritty-colorscheme
  $alclr list \
    | fzf "$@" --preview "
      $alclr apply {}
      bat --color=always --plain --line-range 52:68 ~/.zshrc
      echo
      exa -l /tmp"
)

# +=========================+
# | History Configuration   |
# +-------------------------+

HISTSIZE=10000              #How many lines of history to keep in memory
HISTFILE=~/.zsh_history     #Where to save history to disk
SAVEHIST=10000              #Number of history entries to save to disk
HISTDUP=erase               #Erase duplicates in the history file
setopt EXTENDED_HISTORY
setopt HIST_EXPIRE_DUPS_FIRST
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_FIND_NO_DUPS
setopt HIST_SAVE_NO_DUPS
setopt appendhistory     #Append history to the history file (no overwriting)
setopt sharehistory      #Share history across terminals
setopt incappendhistory  #Immediately append to the history file, not just when a term is killed


# +=========================+
# | Shell configuration     |
# +-------------------------+

setopt autocd extendedglob
bindkey -v

autoload -U edit-command-line
zle -N edit-command-line

bindkey -M vicmd v edit-command-line

# The following lines were added by compinstall
zstyle ':completion:*' completer _complete _ignored _approximate
zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Za-z}' 'l:|=* r:|=*' 'r:|[._-]=* r:|=*'
#zstyle ':completion:*' max-errors 3
zstyle :compinstall filename '${HOME}/.zshrc'

autoload -Uz compinit
compinit
# End of lines added by compinstall

export LANG=en_US.UTF-8
export LC_TIME=en_DK.UTF-8
export EDITOR='nvim'
export MANPAGER='nvim +Man!'

export BAT_THEME=base16-256


# +=========================+
# | Antibody plugin manager |
# +-------------------------+

ANTIBODY_PLUGINS_FILE="${HOME}/.zsh_plugins.sh"

if [ ! -f "${ANTIBODY_PLUGINS_FILE}" -a $commands[antibody] ]
then
    readonly ANTIBODY_PLUGINS=$(<<EOF
hcgraf/zsh-sudo
jeffreytse/zsh-vi-mode
robbyrussell/oh-my-zsh path:lib/git.zsh
robbyrussell/oh-my-zsh path:plugins/docker-machine
robbyrussell/oh-my-zsh path:plugins/git
unixorn/git-extra-commands
zchee/zsh-completions
zdharma-continuum/history-search-multi-word
zsh-users/zsh-autosuggestions
zsh-users/zsh-history-substring-search
zsh-users/zsh-syntax-highlighting
EOF
    )
    antibody bundle <<< "${ANTIBODY_PLUGINS}" > "${ANTIBODY_PLUGINS_FILE}"
fi

if [ -f "${ANTIBODY_PLUGINS_FILE}" ]
then
    ZVM_INIT_MODE=sourcing

    source "${ANTIBODY_PLUGINS_FILE}"
fi


# +=========================+
# | Aliases                 |
# +-------------------------+

# To use `sudo` with aliases
alias sudo='sudo '

alias lsblk+='lsblk -o "NAME,MAJ:MIN,RM,SIZE,RO,FSTYPE,MOUNTPOINT,UUID"'

alias ls='exa'
alias l='ls -l --group-directories-first --git' # --color-scale (has issues on white background)
alias la='l -a'
alias lt='la -s newest'

alias cat='bat'
alias caty='bat -lyaml'
alias tf="terraform"
alias tf11="terraform11"

alias os='openstack'

alias cp="rsync --archive --human-readable --partial --progress"

alias k="kubectl"
alias kd="kubectl describe"
alias kgy="kubectl get -oyaml"
alias kga="kubectl get -A"
alias kc="kubie ctx"
alias kn="kubie ns"

alias dc1="docker-compose1"

ec() { emacs "$@" </dev/null &>/dev/null &; disown }
alias ecc="emacsclient -nc"

function mcd() {
    if [ -d $1 ]; then
        echo "$1 exists"
    else
        mkdir -p $1
        echo "$1 created"
    fi
    cd $1
}

alias gmerge='( read branch && git pull && git merge origin/$branch -m "Merge $branch → $(git symbolic-ref --short -q HEAD)" && git push ) <<<'
alias gship='( read branch && gmerge $branch && git push origin :$branch ) <<<'
alias cpdiff='git diff --color | iconv -f cp1251 -t utf8 | less -r'

alias tru='trans -j en:ru'
alias ten='trans -j ru:en'
alias пер='trans -j ru:en'

alias truen='trans -j ru:en'
alias tenru='trans -j en:ru'

alias tende='trans -j en:de'
alias tdeen='trans -j de:en'

alias trude='trans -j ru:de'
alias tderu='trans -j de:ru'

alias t='task'

alias tt='timew'

alias todo='topydo'
alias todoc='topydo columns'

alias dontgiveup='( read p; until eval $p; do sleep 1; done ) <<<'
alias wanip='curl -s https://ipinfo.io/ip'
alias cleanup='find . -name "*~" -print -exec rm -f {} \;'

alias ffmpeg='ffmpeg -hide_banner'

if [ ! $commands[pbcopy] ]; then
  alias pbcopy="xclip -selection c"
  alias pbpaste="xclip -selection clipboard -o"
fi


# +=========================+
# | PATHs                   |
# +-------------------------+

export PATH="$HOME/.cargo/bin:${PATH}"
export PATH="$HOME/.config/composer/vendor/bin:${PATH}"
export PATH="$HOME/.emacs_doom/bin:${PATH}"
export PATH="$HOME/.krew/bin:${PATH}"
export PATH="$HOME/.local/bin:${PATH}"
export PATH="$HOME/go/bin:${PATH}"
export PATH="$HOME/bin:${PATH}"


export GOPATH="$HOME/go"


# +=========================+
# | pyenv                   |
# +-------------------------+

if [ $commands[pyenv] ]; then
    eval "$(pyenv init -)"
fi


# +=========================+
# | Local npm packages      |
# +-------------------------+

if [ $commands[npm] ]; then
    NPM_PACKAGES="${HOME}/.local/lib/npm_packages"
    export PATH="$NPM_PACKAGES/bin:$PATH"
    NO_UPDATE_NOTIFIER=1 npm config set prefix $NPM_PACKAGES

    # Unset manpath so we can inherit from /etc/manpath via the `manpath` command
    unset MANPATH # delete if you already modified MANPATH elsewhere in your config
    export MANPATH="$NPM_PACKAGES/share/man:$(manpath)"
fi

# +=========================+
# | Starship prompt         |
# +=========================+

eval "$(starship init zsh)"

# +=========================+
# | Library                 |
# +-------------------------+

export TIMEFMT='%J   %U  user %S system %P cpu %*E total'$'\n'\
'avg shared (code):         %X KB'$'\n'\
'avg unshared (data/stack): %D KB'$'\n'\
'total (sum):               %K KB'$'\n'\
'max memory:                %M MB'$'\n'\
'page faults from disk:     %F'$'\n'\
'other page faults:         %R'

# Use fd and fzf to get the args to a command.
# Works only with zsh
# Examples:
# f mv # To move files. You can write the destination after selecting the files.
# f 'echo Selected:'
# f 'echo Selected music:' --extention mp3
# fm rm # To rm files in current directory
f() {
    sels=( "${(@f)$(fd "${fd_default[@]}" "${@:2}"| fzf)}" )
    test -n "$sels" && print -z -- "$1 ${sels[@]:q:q}"
}

# Like f, but not recursive.
fm() f "$@" --max-depth 1

# fco_preview - checkout git branch/tag, with a preview showing the commits between the tag/branch and HEAD
fco_preview() {
  local tags branches target
  branches=$(
    git --no-pager branch --all \
      --format="%(if)%(HEAD)%(then)%(else)%(if:equals=HEAD)%(refname:strip=3)%(then)%(else)%1B[0;34;1mbranch%09%1B[m%(refname:short)%(end)%(end)" \
    | sed '/^$/d') || return
  tags=$(
    git --no-pager tag | awk '{print "\x1b[35;1mtag\x1b[m\t" $1}') || return
  target=$(
    (echo "$branches"; echo "$tags") |
    fzf --no-hscroll --no-multi -n 2 \
        --ansi --preview="git --no-pager log -150 --pretty=format:%s '..{2}'") || return
  git checkout $(awk '{print $2}' <<<"$target" )
}

update_spacemacs_packages() {
    emacs --batch -l ~/.emacs.d/init.el --eval="(configuration-layer/update-packages t)"
}

set_kubeconfig_var() {
    export KUBECONFIG=$(echo ~/.kube/*clusters/*.y?ml(N) | tr ' ' ':')
}

osacme() {
  env $(\
      yq eval --output-format props \
      '.clouds[env(OS_CLOUD)] | explode(.) | (with_entries(select(.key != "auth")), .auth)' \
      ~/.config/openstack/clouds.yaml \
      | sed -r 's/^(\w+) = (.*)/\UOS_\1\E=\2/' \
      | xargs -d '\n') \
    acme.sh --issue --dns dns_openstack --domain "${@}"
}

# +=========================+
# | Autocompletion          |
# +-------------------------+

if [ $commands[stern] ]; then source <(stern --completion zsh); fi

if [ $commands[hcloud] ]; then source <(hcloud completion zsh); fi

if [ $commands[kubectl] ]; then source <(kubectl completion zsh | sed '/"-f"/d'); fi

if [[ -f ~/.config/tabtab/__tabtab.zsh ]]; then source ~/.config/tabtab/__tabtab.zsh; fi


# +=========================+
# | Gnome keyring           |
# +-------------------------+

if [ $commands[gnome-keyring-daemon] ];
then
    eval $(gnome-keyring-daemon --start)
    export GNOME_KEYRING_CONTROL
    export SSH_AUTH_SOCK
fi



GPG_TTY=$(tty)
export GPG_TTY


# +=========================+
# | Command line hooks      |
# +-------------------------+

if [ $commands[zoxide] ]; then
    eval "$(zoxide init zsh)"
    export _ZO_FZF_OPTS='+s --preview "exa -l --group-directories-first -T -L5 --color=always --color-scale {2..} | head -200"'
elif [ $commands[fasd] ]; then eval "$(fasd --init auto)"
# Z and custom FZF wrapper around it
elif [[ -r "/usr/share/z/z.sh" ]]; then
    source /usr/share/z/z.sh

    unalias z

    z() {
      if [[ -z "$*" ]]; then
        cd "$(_z -l 2>&1 | sed 's/^[0-9,.]* *//' | fzf +s --tac --preview ${FZF_DIRECTORY_PREVIEW_CMD})"
      else
        _last_z_args="$@"
        _z "$@"
      fi
    }

    zz() {
      cd "$(_z -l 2>&1 | sed 's/^[0-9,.]* *//' | fzf -q "$_last_z_args")"
    }
fi

if [ $commands[direnv] ]; then eval "$(direnv hook zsh)"; fi

if [ $commands[thefuck] ]; then eval "$(thefuck --alias)"; fi

# +=========================+
# | Various adjustments     |
# +-------------------------+

# Use Docker buildkit by default
export DOCKER_BUILDKIT=1
export COMPOSE_DOCKER_CLI_BUILD=1


if [ $commands[go-task] ]; then
    export GOTASK_BIN=go-task
    alias gt=go-task
fi


# +=========================+
# | Local overrides         |
# +-------------------------+

[[ -r "$HOME/.zshrc.local" ]] && . $HOME/.zshrc.local || true

# pnpm
export PNPM_HOME="/home/zebradil/.local/share/pnpm"
export PATH="$PNPM_HOME:$PATH"
# pnpm end

# +=========================+
# | Inbox functions         |
# +-------------------------+

kubectl::chroot-node() (
# Copyright (c) 2019 Gonçalo Baltazar <me@goncalomb.com>
# MIT License

# Open a root shell on a Kubernetes cluster Node (no ssh).

# It uses a privileged container to unlock Linux capabilities and chroot to
# change into the root filesystem of the Node for full access.

# The Node is selected using the 'kubernetes.io/hostname' label.

local NODE_HOSTNAME="${1:?Usage: $0 NODE_HOSTNAME}"

kubectl run "node-gate-"$NODE_HOSTNAME -it --rm --restart=Never --attach --image=busybox --overrides '
{
	"spec": {
		"nodeSelector": {
			"kubernetes.io/hostname": "'$NODE_HOSTNAME'"
		},
		"hostPID": true,
		"hostIPC": true,
		"hostNetwork": true,
		"containers": [
			{
				"name": "node-gate",
				"image": "busybox",
				"stdin": true,
				"tty": true,
				"command": [
					"chroot", "/mnt/host"
				],
				"securityContext": {
					"privileged": true
				},
				"volumeMounts": [
					{
						"name": "host",
						"mountPath": "/mnt/host"
					}
				]
			}
		],
		"tolerations": [
			{
				"effect": "NoSchedule",
				"operator": "Exists"
			}
		],
		"volumes": [
			{
				"name": "host",
				"hostPath": {
					"path": "/"
				}
			}
		]
	}
}
'
)

kubectl::node-ssh-from-pod() {
  local ctx ns
  local ssh_key
  local node_username

  zparseopts -D -K -E \
    -context:=ctx \
    n:=ns -namespace:=ns \
    i:=ssh_key -identity:=ssh_key \
    l:=node_username -login:=node_username -username:=node_username

  ns=${ns[2]:-$(kubectl::current-namespace)}
  ctx=${ctx[2]:-$(kubectl::current-context)}
  ssh_key=${ssh_key[2]:-${HOME}/.ssh/id_ed25519}
  node_username=${node_username[2]:-core}

  local node="$1" node_ip
  node_ip=$(kubectl --context "$ctx" get node "$node" -o json | \
    jq -er '.metadata.annotations["alpha.kubernetes.io/provided-node-ip"]')
  shift
  local node_cmd="$*"

  if [[ -z "$node_ip" ]]
  then
    echo_error "Failed to determine node IP of $node"
    return 1
  fi

  local pod="ssh-node-${USER}-$(date '+%s')"
  echo_info "Starting pod $pod in $ns (ctx: $ctx)"
  # echo_info "Transfer your key: kubectl --context $ctx cp ${ssh_key} ${pod}:id_ed25519"

  trap "kubectl --context "$ctx" delete pod -n $ns $pod --wait=false >&2" EXIT

  setopt localoptions nonotify nomonitor
  {
    sleep 2  # FIXME is this even necessary?
    if kubectl --context "$ctx" --namespace "$ns" wait --for=condition=ready --timeout=5m pod "$pod" >&2
    then
      echo_warning "Transfering your PRIVATE KEY (${ssh_key}) to the pod"
      kubectl --context "$ctx" --namespace "$ns" cp "${ssh_key}" "${pod}:id_ed25519"
    fi
  } &

  kubectl --context "$ctx" \
    run "$pod" --rm --restart=Never \
    --quiet \
    --namespace "$ns" \
    --stdin=true --tty=true \
    --force=true --grace-period=1 \
    --labels="owner=${USER},purpose=debug,app=node-ssh-via-pod" \
    --env "node_username=${node_username}" \
    --env "node_ip=${node_ip}" \
    --env "node_cmd=${node_cmd}" \
    --image pschmitt/debug \
    -- \
    -c '
      trap "rm -f /id_ed25519" EXIT;
      while [[ ! -r /id_ed25519 ]]
      do
        echo "Waiting for ssh key to magically appear..." >&2
        sleep 1
      done

      chmod 400 /id_ed25519 && \
        ssh -i /id_ed25519 \
          -o UserKnownHostsFile=/dev/null \
          -o StrictHostKeyChecking=no \
        ${node_username}@${node_ip} $node_cmd;
      rm -f /id_ed25519'
}
